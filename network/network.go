package network
import (
	"bytes"
	"centi/util"
	"centi/protocol"
	"centi/cryptography"
)

// queue := make( chan []byte, nc.QueueSize )
func(q *Queue) RunNetwork() {

	for {
		// 1. check if there is a packet in the queue
		// note: all packets in the queue must be packet-sized
		// use CryptClient.PackData and CryptClient.UnpackData functions for this.
		
		packet := &protocol.Message{}
		ok := true
		
		//util.DebugPrintln("Length of sending packets queue:", len(q.queue))
		//util.DebugPrintln("Length of incoming packets queue:", len(q.incoming))

		if len(q.queue) == 0 {	// check if we have a packet in the queue at all
			//util.DebugPrintln("[-] Did not find a packet in the queue, generating a new one...")
			// generate a random packet, if there is no existing packet.
			if q.packetsBuf.Len() > 0 {
				// get packets from the queue...?
				//util.DebugPrintln("[*] We are able to take packets from the buffer.")
				packets, err := q.packetsBuf.Next()
				if err != nil {
					q.Logger.LogError( err )
				} else {
					packet = &protocol.Message{
						"",
						packets[0],
						protocol.UnknownSender,
						false,	// do not optimize this anymire
						map[string]string{},
					}
					if len(packets) > 1 {
						for i := 1; i < len(packets); i++ {
							msg := &protocol.Message{
								"",
								packets[i],
								protocol.UnknownSender,
								false,
								map[string]string{},
							}
							q.queue <- msg
						}
					}
				}
			} else {
				//util.DebugPrintln("Generating random packet....")
				packetData, err := cryptography.GenRandom( q.conn.Config.PacketSize )
				if err != nil {
					q.Logger.LogError( err )
				}

				// pack random data in order not to distinguish fake packets from real ones.
				packet = &protocol.Message{
					"",
					packetData,
					protocol.UnknownSender,
					// actually, it's generated by us, but we don't take
					// it into account during packet optimization
					false,
					map[string]string{},
				}
			}
		} else {
			packet, ok = <- q.queue
			if !ok { // outcoming messages queue is closed
				break
			}
			//util.DebugPrintln( util.CyanColor + "[+] Found packet in the queue:" + util.ResetColor,
			//	cryptography.Hash(packet.Data))
		}

		// 2. send packet if it was not sent yet
		if indb, err := q.db.IsInDB( packet.Data ); indb == false {
			if err != nil {
				q.Logger.LogError(err)
			}
			q.conn.SendToAll( packet.Data )
			// and add it into database
			if err = q.db.AddPacket( packet.Data ); err != nil {
				util.DebugPrintln("Failed to add packet in database:", err)
				q.Logger.LogError( err )
			}

			Sleep( q.conn )	// sleep for some time only in case we sent any packet
		}
	}
}

func(q *Queue) RunNetworkBackground() {

	for {
		messages, err := q.conn.RecvAll()
		if err != nil {
			q.Logger.LogError( err )
		}
		util.DebugPrintf("[protocol::RunNetworkBackground] got %d messages\n", len(messages))
		for _, m := range messages {	
			// check if the message is a valid packet which was not handled before
			if uint(len(m.Data)) == q.conn.Config.PacketSize {
				if indb, _ := q.db.IsInDB( m.Data ); indb == false {
					// we should resend the message in order not to
					// deanonymize ourselves (if we are a receiver).
					if q.closed {
						return
					}

					//q.queue <- m	// this is bullshit
					// resend message right after we got it
					// or our queue will increase infinitely.
					if err = q.db.AddPacket( m.Data ); err != nil {
						util.DebugPrintln("Failed to add packet in database (2):", err)
						q.Logger.LogError( err )
					}
					q.conn.SendToAll( m.Data )

					// try to handle the message ( if possible )
					decrypted := q.tryDecrypt( m )
					if !decrypted {
						q.tryKeyExchange( m )
					}
				} else {
					// packet already exists, and we have (re)sent it.
					// todo: delete it with some probability (? will it still flood the network ?).
					q.conn.Delete( m )
				}
			} else {
				util.DebugPrintln("Size of incoming message:", uint(len(m.Data)))
			}
		}
		Sleep( q.conn )
	}
}

func(q *Queue) RequestPublicKeys( peer *protocol.Peer ) {
	packet, err := peer.PackPkRequest( q.conn.Config.PacketSize )
	if err == nil {
		// just send a packet
		msg := &protocol.Message{
			"",
			packet,
			protocol.UnknownSender,
			false,	// do not take it into account during packet optimization.
			map[string]string{},
		}
		if q.closed {
			return
		}
		q.queue <- msg
	}
}

func(q *Queue) tryDecrypt(m *protocol.Message ) bool {

	decrypted := false
	// check if we are able to decrypt the message
	for _, peer := range q.conn.GetPeers() {
		if peer.ValidSymKey() == false {
			continue
		}

		pct, err := peer.Unpack( m.Data, q.conn.Config.PacketSize )
		if err == nil {
			data, err := cryptography.DecodeData( pct.Body.Data )
			if err == nil {
				if uint(len(data)) >= pct.Body.OrigSize {
					data = data[:pct.Body.OrigSize]
				}
				if pct.Head.Compressed != uint8(0) {
					// data in the packet is compressed.
					// decompress it.
					data, err = protocol.Decompress( data )
					if err != nil {
						// failed to correctly decrypt packet.
						return false
					}
				}
				util.DebugPrintln("Unpacked data:", string(data))
				decrypted = true
				switch pct.Head.Typ {
				case protocol.RetransmitPct: // we must resend the packet
					//util.DebugPrintln("Handling retransmit packate")
					q.handleRetransmitPacket( data )

				case protocol.PkReqPct:
					//util.DebugPrintln("Handling public key request package")
					q.handlePkRequest( pct, data, peer )

				case protocol.PkPct:	// should we send public keys?
					//util.DebugPrintln("Handling public key response package")
					q.handlePkPacket( pct, data, peer )

				case protocol.DataPct: // does the packet contains data?
					//util.DebugPrintln("Handling message from peer")
					q.handleDataPacket( pct, data, peer )
				}
			} /*else {
				util.DebugPrintln("[queue::tryDecrypt] failed to decode data:", err)
			}*/
			break
		} //else {
			//util.DebugPrintf("[queue::tryDecrypt] peer %s failed to unpack data: %s\n",
			//	peer.GetAlias(), err.Error())
		// }
	}
	return decrypted
}

func(q *Queue) tryKeyExchange(m *protocol.Message ) {
	if q.conn.Config.AcceptUnknown {	// if we are accepting incoming connections

		ss, ecPkDec, hmac, err := q.conn.CrClient.DecapsulateAndUnpack(
			q.conn.Config.PacketSize,
			m.Data )
		
		// if we were able to decapsulate shared secret, that means that the packet
		// was sent to us.
		if err == nil {
			
			haveSS := false
			peers := q.conn.GetPeers()
			for _, p := range peers {
				if bytes.Equal( p.GetKey(), ss ) == true {
					haveSS = true
					break
				}
			}
			// check who is writing to us...
			if haveSS == false {
				// check if we know the person already
				for _, peer := range q.conn.GetPeers() {
					networkSubkey := []byte{}
					for k, v := range q.NetworkSubkeys {
						if k == peer.GetAlias() {
							networkSubkey = v
							break
						}
					}
					if peer.Equals( ecPkDec ) {
						//util.DebugPrintln("Found a peer with same public key:",
						//	peer.GetAlias())
						if len(networkSubkey) == 0 || cryptography.VerifyHMACBytes( ecPkDec, networkSubkey, hmac ) == true {
							peer.SetKey( ss )
							return
						} else {
							util.DebugPrintln("Peer wanted to appear as someone else")
						}
					}
				}

				// someone who connects to us
				// isn't known to us (or uses ephemerial mode).
				newPeer := protocol.NewPeer( util.GenID() )
				newPeer.SetEccPk( ecPkDec )
				newPeer.SetKey( ss )

				util.DebugPrintln(
					"[protocol::RunNetworkBackground] Adding a new peer:",
					newPeer.Alias)
				q.conn.AddPeer( newPeer )
			}
		} /*else {
			util.DebugPrintln("[tryKeyExchange] Failed to unpack and decapsulate shared secret:", 
				err)
		}*/
	}
}

func(q *Queue) handleRetransmitPacket( data []byte ) {
	util.DebugPrintln("The message must be resent...")
	// resend a cleared packet in queue
	newMsg := &protocol.Message{
		"",
		data,
		protocol.UnknownSender,
		false,	// do not optimize this packet.
		map[string]string{},
	}

	if q.closed {
		return
	}

	q.queue <- newMsg
}

func(q *Queue) handlePkRequest( pct *protocol.Packet, data []byte, peer *protocol.Peer ) {
	
	// are we allowed to send public keys of our friends?
	if q.conn.Config.SendKnownPeers {
		// yes, we can send them
		packets, err := peer.PackPublicKeys( q.conn.GetPeers(), q.conn.Config.PacketSize )
		if err == nil {
			for _, p := range packets {
				msg := &protocol.Message{
					"",
					p,
					protocol.UnknownSender,
					false,	// don't take it into account during packet optimization
					map[string]string{},
				}
				if q.closed {
					return
				}

				q.queue <- msg
			}
		} else {
			util.DebugPrintln("Failed to pack public keys:", err)
		}
	} else {
		// no, we must keep them secret.
		packets, err := peer.PackPublicKeys( nil, q.conn.Config.PacketSize )
		if err != nil {
			util.DebugPrintln("[TODO]: change public keys dummy packing....")
		} else {
			for _, p := range packets {
				msg := &protocol.Message{
					"",
					p,
					protocol.UnknownSender,
					false,	// the same thing.
					map[string]string{},
				}

				if q.closed {
					return
				}
				q.queue <- msg
			}
		}
	}
}


func(q *Queue) handlePkPacket( pct *protocol.Packet, data []byte, peer *protocol.Peer ) {
	// handle incoming public keys list
	if pct.Head.Total == 1 {
		// all public keys are in just one packet
		return
	}

	// handle a sequence of messages
	q.pkHandler.AddPacket( peer.Alias, pct.Head.Seq, pct.Head.Total, pct.Head.Compressed, data )
	data = q.pkHandler.ByAlias( peer.Alias )
	if data != nil {
		util.DebugPrintln("[+] Collected public key data packet")
		// update list of public keys
		publicKeys, err := peer.UnpackPublicKeys( data, q.conn.Config.PacketSize )
		if err == nil {
			util.DebugPrintln("[handlePkPacket] Amount of collected public keys:", len(publicKeys))
			for _, pk := range publicKeys {
				//exists := false
				// check if don't have any public key with similar alias
				/*for _, p := range q.conn.GetPeers() {
					if p.Alias == pk.Alias {
						exists = true
						break
					}
				}
				// append, if needed
				if exists == false {
				*/
				util.DebugPrintln("Adding a new public key for peer ", pk.Alias)
					newPeer := protocol.NewPeer( pk.Alias )
					if err = newPeer.SetPk( pk.Content, q.conn.Peers.NetworkSubkey() ); err == nil {
						q.conn.AddPeer( newPeer )
					}
				//}
			}
		} else {
			util.DebugPrintln("[----] UnpackPublicKeys failed:", err)
		}
	}
}

func(q *Queue) handleDataPacket( pct *protocol.Packet, data []byte, peer *protocol.Peer ) {

	if pct.Head.Total == 1 {
		// have only one packet, skip the opera
		newMsg := &protocol.Message{
			"",
			data,
			peer.Alias,
			false,
			map[string]string{},
		}

		if q.closed {
			util.DebugPrintln("Queue is closed...???")
			return
		}
		q.incoming <- newMsg
		return
	}

	// handle a sequence of messages
	q.msgHandler.AddPacket( peer.Alias, pct.Head.Seq, pct.Head.Total, pct.Head.Compressed, data )
	data = q.msgHandler.ByAlias( peer.Alias )
	if data != nil {
		newMsg := &protocol.Message{
			"",
			data,
			peer.Alias,
			false,
			map[string]string{},
		}
		if q.closed {
			return
		}
		q.incoming <- newMsg
	}
}
